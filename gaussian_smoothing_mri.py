# -*- coding: utf-8 -*-
"""Gaussian smoothing MRI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1svcRxjNPzyO3iNUGD-Wb_E3yEGjnXrrR

# **Gaussian smoothing across all orig.nii files**
"""

from google.colab import drive
drive.mount('/content/drive')

"""**Check the affine matrix**

*We first apply a testing filter to visualize the choice of FWHM.*

*1mm in voxel should be 0,5mm in FHWM, but we need to visualize to see what differences each mm give.*
"""

import nibabel as nib

nifti_img = nib.load('/content/drive/MyDrive/MASTER THESIS/CODE & MODELLING/DATABASE/!THESIS! - (after "recon-all" and .mgz --> .nii)/AD/003_S_6833/003_S_6833_orig.nii')

header = nifti_img.header
print(header)

affine = nifti_img.affine
print(affine)
current_orientation = nib.aff2axcodes(affine)
print("Current orientation:", current_orientation)
image_data = nifti_img.get_fdata()
print("Image data shape:", image_data.shape)

"""The data is oriented in LIA' ('Left'-'Inferior'-'Anterior'). The current orientation tells us that:

- *The first dimension (256) is Left to Right (L).*
- *The second dimension (256) is Inferior to Superior (I).*
- *The third dimension (256) is Anterior to Posterior (A).*

We can then apply the Gaussian filter to check for FWHM information in the AXIAL viewing plane.
"""

import numpy as np
import matplotlib.pyplot as plt
import nibabel as nib
from scipy.ndimage import gaussian_filter

def fwhm_to_sigma(fwhm):
    return fwhm / np.sqrt(8 * np.log(2))

# Load the NIfTI file
file_path = '/content/drive/MyDrive/MASTER THESIS/CODE & MODELLING/DATABASE/!THESIS! - (after "recon-all" and .mgz --> .nii)/AD/003_S_6833/003_S_6833_orig.nii'
nifti_img = nib.load(file_path)
image_data = nifti_img.get_fdata()

fwhm_values = [0.5, 1, 2, 3]
sigma_values = [fwhm_to_sigma(fwhm) for fwhm in fwhm_values]

middle_slice_index = image_data.shape[1] // 2

fig, axes = plt.subplots(1, len(fwhm_values) + 1, figsize=(20, 4))


original_slice = np.flipud(image_data[:, middle_slice_index, :])

axes[0].imshow(original_slice.T, cmap='gray', origin='lower')
axes[0].set_title('Original Image')
axes[0].axis('off')

for i, sigma in enumerate(sigma_values):
    smoothed_data = gaussian_filter(image_data, sigma=sigma)
    smoothed_slice = np.flipud(smoothed_data[:, middle_slice_index, :])
    axes[i + 1].imshow(smoothed_slice.T, cmap='gray', origin='lower')
    axes[i + 1].set_title(f'FWHM = {fwhm_values[i]}mm')
    axes[i + 1].axis('off')

plt.tight_layout()
plt.show()

"""Based on the trial on one subjects orig.nii, the best solotion is as expected 0,5 mm since this is keeping all information in the image.

**Applying Gaussian smoothing across the whole orig.nii dataset**

We process this in batches of 50 scans to ensure that we do not overload the RAM which can cause significant problems.
"""

import os
import numpy as np
import nibabel as nib
from scipy.ndimage import gaussian_filter

def fwhm_to_sigma(fwhm):
    return fwhm / np.sqrt(8 * np.log(2))


fwhm = 0.5
sigma = fwhm_to_sigma(fwhm)

input_directory = '/content/drive/MyDrive/MASTER THESIS/CODE & MODELLING/DATABASE/!THESIS! - (after "recon-all" and .mgz --> .nii)'
output_directory = '/content/drive/MyDrive/MASTER THESIS/CODE & MODELLING/DATABASE/!THESIS! GAUSSIAN SMOOTHING'

def process_batch(files_batch):
    for file_path in files_batch:

        nifti_img = nib.load(file_path)
        image_data = nifti_img.get_fdata()

        # Apply Gaussian smoothing
        smoothed_data = gaussian_filter(image_data, sigma=sigma)

        # Create a new NIfTI image from the smoothed data, using the original image's affine matrix
        smoothed_img = nib.Nifti1Image(smoothed_data.astype(np.float32), nifti_img.affine)

        # Construct the output file path
        relative_path = os.path.relpath(file_path, input_directory)
        output_file_path = os.path.join(output_directory, relative_path)
        output_subdirectory = os.path.dirname(output_file_path)
        if not os.path.exists(output_subdirectory):
            os.makedirs(output_subdirectory)

        nib.save(smoothed_img, output_file_path)
        print(f"Processed and saved: {output_file_path}")


all_files = []

for root, dirs, files in os.walk(input_directory):
    for file in files:
        if file.endswith('_orig.nii'):
            all_files.append(os.path.join(root, file))

# Process files in batches of 50
for i in range(0, len(all_files), 50):
    batch_files = all_files[i:i+50]
    process_batch(batch_files)